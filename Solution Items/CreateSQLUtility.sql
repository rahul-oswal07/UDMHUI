/*
 * AUTHOR: SOUMYA
 * CREATION DATE: 20/07/2015
 * DESCRIPTION: THIS SQL CODE APPLIES FOR SQL UTILITY FUNCTIONS.
 * REVISION HISTORY:
 *-----------------------------------------------------------------------------------------------------
 * VERSION      DATE            DEVELOPER               DESCRIPTION
 *-----------------------------------------------------------------------------------------------------
    1.0         20/07/2015       SOUMYA              THIS SQL CODE APPLIES FOR SQL UTILITY FUNCTIONS
 *-----------------------------------------------------------------------------------------------------
 */


--------------------------------------------REGISTERING SQLUTILITY.DLL START-----------------------------------------------------------------
/*STEP 1: */

ALTER DATABASE "{0}" SET TRUSTWORTHY ON
GO

SP_CONFIGURE 'SHOW ADVANCED OPTIONS', 1;
GO
RECONFIGURE;
GO

SP_CONFIGURE 'CLR ENABLED', 1;
GO
RECONFIGURE;
GO

SP_CONFIGURE 'SHOW ADVANCED OPTIONS', 0;
GO
RECONFIGURE;
GO

/*STEP 2:*/
DECLARE @COMMAND NVARCHAR(MAX) 
SET @COMMAND = N'ALTER AUTHORIZATION ON DATABASE::<<DATABASENAME>> TO <<LOGINNAME>>' 
 SELECT @COMMAND = REPLACE 
                  ( 
                     REPLACE(@COMMAND, N'<<DATABASENAME>>', QUOTENAME(SD.NAME)) 
                    ,N'<<LOGINNAME>>' 
                    ,QUOTENAME
                     (
                      COALESCE
                      (
                        SL.NAME 
                       ,(SELECT TOP 1 NAME FROM SYS.SERVER_PRINCIPALS WHERE TYPE_DESC = 'SQL_LOGIN' AND IS_DISABLED = 'FALSE' ORDER BY PRINCIPAL_ID ASC )
                      )
                     )
                  ) 
 FROM SYS.DATABASES AS SD
 LEFT JOIN SYS.SERVER_PRINCIPALS  AS SL 
   ON SL.SID = SD.OWNER_SID 
WHERE SD.NAME = DB_NAME() 

PRINT @COMMAND 
EXECUTE(@COMMAND) 
GO

/*STEP 3:*/
/* DROP ASSEMBLY SQLUTILITY FUNCTIONS FOR CREATING A NEW ASSEMBLY*/
IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMATDATE') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMATDATE

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMATVARCHAR') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMATVARCHAR

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMATINT') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMATINT

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMATDECIMAL') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMATDECIMAL

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_REGEXISMATCH') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_REGEXISMATCH

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_REGEXMATCHEXTRACT') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_REGEXMATCHEXTRACT

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_REGEXMATCHREPLACE') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_REGEXMATCHREPLACE

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMAT_EXCEPTION') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMAT_EXCEPTION


/* DROP ASSEMBLY SQLUTILITY*/
IF EXISTS(SELECT * FROM SYS.ASSEMBLIES WHERE NAME='SQLUTILITY') 
DROP ASSEMBLY SQLUTILITY

/* CREATION OF ASSEMBLY SQLUTILITY */

CREATE ASSEMBLY SQLUTILITY
           FROM  '{1}'
           WITH PERMISSION_SET = UNSAFE

--------------------------------------------REGISTERING SQLUTILITY.DLL END-----------------------------------------------------------------

--------------------------------------------Generating SCALAR function from SQLUTILITY.DLL START-----------------------------------------------------------------
/* <SUMMARY>
FUNCTION WILL TAKE THE DATE FIELD VALUES FOR FORMATTING, IF THE DATE VALUE IS NULL THEN IT RETURNS EIGHT ZEROES. 
IF ITS A VALID DATE RETURNS THE FORMATED VALUE REMOVING '-'
</SUMMARY>
<FUNCTION NAME="FN_FORMATDATE">NAME OF THE FUNCTION</FUNCTION>
<PARAM NAME="FLD_VAL">VALUE OF THE FIELD</PARAM>
<PARAM NAME="EXP_LEN">LENGTH OF THE FIELD</PARAM>
<PARAM NAME="FLD_NAME">NAME OF THE FIELD</PARAM>
<PARAM NAME="REC_TYPE">RECORD TYPE</PARAM>
<PARAM NAME="X02_KEY">ACCOUNT NUMBER OF THE PARTICULAR TARGET TYPE</PARAM>
<RETURNS>DATE VALUE</RETURNS>
*/
IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMATDATE') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMATDATE
GO

 /* NOTE:WHY WE ARE USING THE NVARCHAR DATA TYPE PARTICULARLY
 WHEN WE ARE USING DATA TYPE (VARCHAR) FOR GENERATING THE FUNCTIONS OF UTILITY THROWING THE ERROR LIKE "T-SQL AND CLR TYPES FOR PARAMETER DO NOT MATCH".
 BECAUSE, USING THE SQLSTRING DATA TYPE IN DLL FUNCTIONS. IN DLL WE DON'T HAVE THE DATA TYPE WHICH WILL MATCH FOR VARCHAR.
*/

CREATE FUNCTION dbo.FN_FORMATDATE 
(
   @FLD_VAL DATETIME
  ,@EXP_LEN INT
  ,@FLD_NAME NVARCHAR(200) 
  ,@REC_TYPE NVARCHAR(20)
  ,@X02_KEY NVARCHAR(20)
)
RETURNS NVARCHAR(MAX) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [SQLUTILITY].[SQLUtility.BaseFunctionClass].FN_FORMATDATE
GO

/*<SUMMARY>
 FUNCTION WILL TAKE ALL THE DECIMAL FIELD VALUES FOR FORMATTING DATA 
 IF THE VALUE IS NULL THEN WILL RETURN ZEROES OF EXPECTED LENGTH,
 IF THE VALUE IS GREATER THAN THE EXPECTED LENGTH THEN WILL RAISE AN EXCEPTION AND RETURN THE EXPECTED LENGTH VALUE ,
 IF THE VALUE IS LESS THAN THE EXPECTED LENGTH THEN WILL RETURN THE VALUE AS IS AND PAD THE ZEROES LEFT 
 IF THE VALUE IS EQUAL TO THE EXPECTED LENGTH THEN WILL RETURN THE VALUE AS IS 
</SUMMARY>
<FUNCTION NAME="FN_FORMATDECIMAL">NAME OF THE FUNCTION</FUNCTION>
<PARAM NAME="FLD_VAL">VALUE OF THE FIELD</PARAM>
<PARAM NAME="EXP_LEN">LENGTH OF THE FIELD</PARAM>
<PARAM NAME="FLD_NAME">NAME OF THE FIELD</PARAM>
<PARAM NAME="REC_TYPE">RECORD TYPE</PARAM>
<PARAM NAME="X02_KEY">ACCOUNT NUMBER OF THE PARTICULAR TARGET TYPE</PARAM>
<RETURNS>DATE VALUE</RETURNS>*/
IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMATDECIMAL') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMATDECIMAL
GO
CREATE FUNCTION dbo.FN_FORMATDECIMAL
(
   @FLD_VAL DECIMAL(20,6)
  ,@EXP_LEN INT
  ,@FLD_NAME NVARCHAR(200) 
  ,@REC_TYPE NVARCHAR(20)
  ,@X02_KEY NVARCHAR(20)
)
RETURNS NVARCHAR(MAX) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [SQLUTILITY].[SQLUtility.BaseFunctionClass].FN_FORMATDECIMAL
GO


IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMATVARCHAR') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMATVARCHAR
GO

CREATE FUNCTION dbo.FN_FORMATVARCHAR
(
   @FLD_VAL NVARCHAR(200)
  ,@EXP_LEN INT
  ,@FLD_NAME NVARCHAR(200)
  ,@REC_TYPE NVARCHAR(20)
  ,@X02_KEY NVARCHAR(20)
)
RETURNS NVARCHAR(MAX) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [SQLUTILITY].[SQLUtility.BaseFunctionClass].FN_FORMATVARCHAR
GO

/*<SUMMARY>
 FUNCTION WHICH WILL TAKE ALL THE INTEGER FIELD VALUES FOR FORMATTING DATA, 
 IF THE VALUE IS NULL THEN WILL RETURN ZEROES OF EXPECTED LENGTH,
 IF THE VALUE IS GREATER THAN THE EXPECTED LENGTH THEN WILL RAISE AN EXCEPTION AND RETURN THE EXPECTED LENGTH VALUE,
 IF THE VALUE IS LESS THAN THE EXPECTED LENGTH THEN WILL RETURN THE VALUE AS IS AND PAD THE ZEROES LEFT 
 IF THE VALUE IS EQUAL TO THE EXPECTED LENGTH THEN WILL RETURN THE VALUE AS IS 
</SUMMARY>
<FUNCTION NAME="FN_FORMATINT">NAME OF THE FUNCTION</FUNCTION>
<PARAM NAME="FLD_VAL">VALUE OF THE FIELD</PARAM>
<PARAM NAME="EXP_LEN">LENGTH OF THE FIELD</PARAM>
<PARAM NAME="FLD_NAME">NAME OF THE FIELD</PARAM>
<PARAM NAME="REC_TYPE">RECORD TYPE</PARAM>
<PARAM NAME="X02_KEY">ACCOUNT NUMBER OF THE PARTICULAR TARGET TYPE</PARAM>
<RETURNS>DATE VALUE</RETURNS> */
IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMATINT') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMATINT
GO

CREATE FUNCTION dbo.FN_FORMATINT
(
   @FLD_VAL BIGINT
  ,@EXP_LEN INT
  ,@FLD_NAME NVARCHAR(200) 
  ,@REC_TYPE NVARCHAR(20)
  ,@X02_KEY NVARCHAR(20)
)
RETURNS NVARCHAR(MAX) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [SQLUTILITY].[SQLUtility.BaseFunctionClass].FN_FORMATINT
GO

/* <SUMMARY>
 IF THE PATTERN MATCHED THEN WILL RETURN THE EMPTY STRING ELSE RETURN THE INPUT 
</SUMMARY>
<FUNCTION NAME="FN_REGEXMATCHREPLACE">NAME OF THE FUNCTION</FUNCTION>
<PARAM NAME="PATTERN">REGULAR EXPRESSION</PARAM>
<PARAM NAME="INPUT">INPUT PARAMETER</PARAM>
<RETURNS>MATCHED STRING</RETURNS> */
IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_REGEXMATCHREPLACE') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_REGEXMATCHREPLACE
GO

CREATE FUNCTION dbo.FN_REGEXMATCHREPLACE
(
   @PATTERN NVARCHAR(4000)
  ,@INPUT NVARCHAR(MAX)
)
RETURNS NVARCHAR(MAX) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [SQLUTILITY].[SQLUtility.BaseFunctionClass].FN_REGEXMATCHREPLACE
GO

/* <SUMMARY>
IF THE PATTERN MATCHED THEN WILL RETURN INPUT ELSE RETURN EMPTY STRING
</SUMMARY>
<FUNCTION NAME="FN_REGEXMATCHEXTRACT">NAME OF THE FUNCTION</FUNCTION>
<PARAM NAME="PATTERN">REGULAR EXPRESSION</PARAM>
<PARAM NAME="INPUT">INPUT PARAMETER</PARAM>
<RETURNS>MATCHED STRING</RETURNS> */
IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_REGEXMATCHEXTRACT') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_REGEXMATCHEXTRACT
GO

CREATE FUNCTION dbo.FN_REGEXMATCHEXTRACT
(
   @PATTERN NVARCHAR(4000)
  ,@INPUT NVARCHAR(MAX)
)
RETURNS NVARCHAR(MAX)
AS EXTERNAL NAME 
  [SQLUTILITY].[SQLUtility.BaseFunctionClass].FN_REGEXMATCHEXTRACT
GO

/* <SUMMARY>
IF THE PAATERN MATCHED THEN WILL RETURN THE BOOLEAN VALUE 1 ELSE RETURN 0
</SUMMARY>
<FUNCTION NAME="FN_REGEXISMATCH">NAME OF THE FUNCTION</FUNCTION>
<PARAM NAME="PATTERN">REGULAR EXPRESSION</PARAM>
<PARAM NAME="INPUT">INPUT PARAMETER</PARAM>
<RETURNS>MATCHED STRING</RETURNS> */
IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_REGEXISMATCH') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_REGEXISMATCH
GO

CREATE FUNCTION dbo.FN_REGEXISMATCH
(
   @PATTERN NVARCHAR(4000)
  ,@INPUT NVARCHAR(MAX)
)
RETURNS [BIT] WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [SQLUTILITY].[SQLUtility.BaseFunctionClass].FN_REGEXISMATCH
GO 

/* <SUMMARY>
FUNCTION FOR FN_EXCEPTION TABLE WHICH WILL HAVE ALL EXCEPTIONS FROM FORMATTING VIEW FUNCTIONS
</SUMMARY>
<FUNCTION NAME="FN_FORMAT_EXCEPTION">NAME OF THE FUNCTION</FUNCTION>
<PARAM NAME="STREXCEPTDATETIME">CURRENT DATE (GETDATE())</PARAM>
<PARAM NAME="STREXCEPTSRCKEY1">REPRESENTS THE X02_KEY</PARAM>
<PARAM NAME="STREXCEPTCODE">NAME OF THE ISSUE</PARAM>
<PARAM NAME="STREXCEPTSRCFIELD1">NAME OF THE FIELD</PARAM>
<PARAM NAME="STREXCEPTSRCVALUE1">VALUE OF THE FIELD</PARAM>
<PARAM NAME="STREXCEPTSEVERITY">SEVERITY OF THE ISSUE LIKE WARNING, INFORMATION</PARAM>
<PARAM NAME="STREXCEPTCOMPONENT">NAME OF THE TARGET TYPE</PARAM>
<RETURNS>EXCEPTION DATA</RETURNS> */
IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_FORMAT_EXCEPTION') AND TYPE IN (N'FS'))
DROP FUNCTION dbo.FN_FORMAT_EXCEPTION
GO
	
CREATE FUNCTION dbo.FN_FORMAT_EXCEPTION
(
	@EXCEPT_PACKAGE NVARCHAR(100)
	,@STREXCEPTCODE NVARCHAR(50)
	,@STREXCEPTSEVERITY NVARCHAR(1)
	,@EXCEPT_ACCOUNT_NO NVARCHAR(16)
	,@EXCEPT_SRC_FIELD_1 NVARCHAR(100)
	,@EXCEPT_SRC_VALUE_1 NVARCHAR(1000)
	,@EXCEPT_SRC_FIELD_2 NVARCHAR(100)
	,@EXCEPT_SRC_VALUE_2 NVARCHAR(1000)
	,@EXCEPT_SRC_FIELD_3 NVARCHAR(100)
	,@EXCEPT_SRC_VALUE_3 NVARCHAR(1000)
	,@EXCEPT_SRC_FIELD_4 NVARCHAR(100)
	,@EXCEPT_SRC_VALUE_4 NVARCHAR(1000)
	,@EXCEPT_SRC_FIELD_5 NVARCHAR(100)
	,@EXCEPT_SRC_VALUE_5 NVARCHAR(1000)
	,@EXCEPT_SRC_FIELD_6 NVARCHAR(100)
	,@EXCEPT_SRC_VALUE_6 NVARCHAR(1000)
)
RETURNS NVARCHAR(MAX)
AS EXTERNAL NAME SQLUTILITY.[SQLUtility.BaseFunctionClass].FN_FORMAT_EXCEPTION 
GO

--------------------------------------------Generating SCALAR function from SQLUTILITY.DLL END-----------------------------------------------------------------

--------------------------------------------Generating XML format Exception START-----------------------------------------------------------------
/* CREATION OF THE EXCEPTION FUNCTION FOR BASE QUERY*/


IF OBJECT_ID(N'dbo.FN_EXCEPTION',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_EXCEPTION')) IS NOT NULL
DROP FUNCTION dbo.FN_EXCEPTION
GO

CREATE FUNCTION dbo.FN_EXCEPTION
(
   @EXCEPT_PACKAGE VARCHAR(100)
  ,@EXCEPT_CODE VARCHAR(50)
  ,@EXCEPT_SEVERITY CHAR(1)
  ,@EXCEPT_ACCOUNT_NO VARCHAR(16)
  ,@EXCEPT_SRC_FIELD_1 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_1 VARCHAR(1000)
  ,@EXCEPT_SRC_FIELD_2 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_2 VARCHAR(1000)
  ,@EXCEPT_SRC_FIELD_3 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_3 VARCHAR(1000)
  ,@EXCEPT_SRC_FIELD_4 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_4 VARCHAR(1000)
  ,@EXCEPT_SRC_FIELD_5 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_5 VARCHAR(1000)
  ,@EXCEPT_SRC_FIELD_6 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_6 VARCHAR(1000) 
)
RETURNS @EX TABLE (
  EX XML
)
AS
BEGIN
    DECLARE @RESULT XML
    SET @RESULT = CAST((SELECT  
                       @EXCEPT_PACKAGE        AS EXCEPT_PACKAGE
                      ,@EXCEPT_CODE           AS EXCEPT_CODE
                      ,@EXCEPT_SEVERITY       AS EXCEPT_SEVERITY   
                      ,@EXCEPT_ACCOUNT_NO     AS EXCEPT_ACCOUNT_NO 
                      ,@EXCEPT_SRC_FIELD_1    AS EXCEPT_SRC_FIELD_1
                      ,@EXCEPT_SRC_VALUE_1    AS EXCEPT_SRC_VALUE_1
                      ,@EXCEPT_SRC_FIELD_2    AS EXCEPT_SRC_FIELD_2
                      ,@EXCEPT_SRC_VALUE_2    AS EXCEPT_SRC_VALUE_2
                      ,@EXCEPT_SRC_FIELD_3    AS EXCEPT_SRC_FIELD_3
                      ,@EXCEPT_SRC_VALUE_3    AS EXCEPT_SRC_VALUE_3
                      ,@EXCEPT_SRC_FIELD_4    AS EXCEPT_SRC_FIELD_4
                      ,@EXCEPT_SRC_VALUE_4    AS EXCEPT_SRC_VALUE_4
                      ,@EXCEPT_SRC_FIELD_5    AS EXCEPT_SRC_FIELD_5
                      ,@EXCEPT_SRC_VALUE_5    AS EXCEPT_SRC_VALUE_5
                      ,@EXCEPT_SRC_FIELD_6    AS EXCEPT_SRC_FIELD_6
                      ,@EXCEPT_SRC_VALUE_6    AS EXCEPT_SRC_VALUE_6
                                FOR XML RAW) AS XML                            )
    
    SET @RESULT = (SELECT @RESULT FOR XML PATH (''))
    INSERT INTO @EX(EX) VALUES (@RESULT)
    RETURN 
END
GO

IF OBJECT_ID(N'dbo.FN_EXCEPTION1',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_EXCEPTION1')) IS NOT NULL
DROP FUNCTION dbo.FN_EXCEPTION1
GO

CREATE  FUNCTION dbo.FN_EXCEPTION1
(
   @EXCEPT_PACKAGE VARCHAR(100)
  ,@EXCEPT_SEVERITY_CODE VARCHAR(50)
  ,@EXCEPT_ACCOUNT_NO VARCHAR(16)
  ,@EXCEPT_SRC_FIELD_1 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_1 VARCHAR(1000)
 )
RETURNS @EXCEPTBL TABLE 
(
    EXCEP XML
 )
AS 
BEGIN
     INSERT INTO @EXCEPTBL(EXCEP) 
       SELECT * FROM  dbo.FN_EXCEPTION( @EXCEPT_PACKAGE
                             ,SUBSTRING(@EXCEPT_SEVERITY_CODE,3,LEN(@EXCEPT_SEVERITY_CODE)-2)
                             ,SUBSTRING(@EXCEPT_SEVERITY_CODE,1,1)
                             ,@EXCEPT_ACCOUNT_NO
                             ,@EXCEPT_SRC_FIELD_1
                             ,@EXCEPT_SRC_VALUE_1
                             ,'','','','','','','','','','' )
     RETURN 
  
END
GO

IF OBJECT_ID(N'dbo.FN_EXCEPTION2',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_EXCEPTION2')) IS NOT NULL
DROP FUNCTION dbo.FN_EXCEPTION2
GO

CREATE  FUNCTION dbo.FN_EXCEPTION2
(
   @EXCEPT_PACKAGE VARCHAR(100)
  ,@EXCEPT_SEVERITY_CODE VARCHAR(50)
  ,@EXCEPT_ACCOUNT_NO VARCHAR(16)
  ,@EXCEPT_SRC_FIELD_1 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_1 VARCHAR(1000)
  ,@EXCEPT_SRC_FIELD_2 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_2 VARCHAR(1000)
 )
RETURNS @EXCEPTBL TABLE 
(
    EXCEP XML
 )
AS 
BEGIN
     INSERT INTO @EXCEPTBL(EXCEP) 
       SELECT * FROM  dbo.FN_EXCEPTION( @EXCEPT_PACKAGE
                             ,SUBSTRING(@EXCEPT_SEVERITY_CODE,3,LEN(@EXCEPT_SEVERITY_CODE)-2)
                             ,SUBSTRING(@EXCEPT_SEVERITY_CODE,1,1)
                             ,@EXCEPT_ACCOUNT_NO
                             ,@EXCEPT_SRC_FIELD_1
                             ,@EXCEPT_SRC_VALUE_1
                             ,@EXCEPT_SRC_FIELD_2
                             ,@EXCEPT_SRC_VALUE_2
                             ,'','','','','','','','' )
     RETURN 
  
END
GO

IF OBJECT_ID(N'dbo.FN_EXCEPTION3',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_EXCEPTION3')) IS NOT NULL
DROP FUNCTION dbo.FN_EXCEPTION3
GO

CREATE  FUNCTION dbo.FN_EXCEPTION3
(
   @EXCEPT_PACKAGE VARCHAR(100)
  ,@EXCEPT_SEVERITY_CODE VARCHAR(50)
  ,@EXCEPT_ACCOUNT_NO VARCHAR(16)
  ,@EXCEPT_SRC_FIELD_1 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_1 VARCHAR(1000)
  ,@EXCEPT_SRC_FIELD_2 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_2 VARCHAR(1000)
  ,@EXCEPT_SRC_FIELD_3 VARCHAR(100)
  ,@EXCEPT_SRC_VALUE_3 VARCHAR(1000)
 )
RETURNS @EXCEPTBL TABLE 
(
    EXCEP XML
 )
AS 
BEGIN
     INSERT INTO @EXCEPTBL(EXCEP) 
       SELECT * FROM  dbo.FN_EXCEPTION( @EXCEPT_PACKAGE
                             ,SUBSTRING(@EXCEPT_SEVERITY_CODE,3,LEN(@EXCEPT_SEVERITY_CODE)-2)
                             ,SUBSTRING(@EXCEPT_SEVERITY_CODE,1,1)
                             ,@EXCEPT_ACCOUNT_NO
                             ,@EXCEPT_SRC_FIELD_1
                             ,@EXCEPT_SRC_VALUE_1
                             ,@EXCEPT_SRC_FIELD_2
                             ,@EXCEPT_SRC_VALUE_2
                             ,@EXCEPT_SRC_FIELD_3
                             ,@EXCEPT_SRC_VALUE_3
                             ,'','','','','','' )
     RETURN 
  
END
GO

IF OBJECT_ID(N'dbo.FN_ADDRESS_SPLIT',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_ADDRESS_SPLIT')) IS NOT NULL
DROP FUNCTION dbo.FN_ADDRESS_SPLIT
GO

CREATE FUNCTION dbo.FN_ADDRESS_SPLIT
(
   @AL1 NVARCHAR(MAX) = NULL
  ,@AL2 NVARCHAR(MAX) = NULL
  ,@AL3 NVARCHAR(MAX) = NULL
  ,@AL4 NVARCHAR(MAX) = NULL
  ,@AL5 NVARCHAR(MAX) = NULL
  ,@AL6 NVARCHAR(MAX) = NULL
  ,@AL7 NVARCHAR(MAX) = NULL
  ,@X02_KEY VARCHAR(16)  = NULL
  ,@REC_CODE CHAR(7)  = NULL
)
RETURNS
@PARSED_OUT_ADDR TABLE
(
   PREMISE_NAME NVARCHAR(40)
  ,PREMISE_NO NVARCHAR(6)
  ,STREET NVARCHAR(40)
  ,DISTRICT NVARCHAR(40)
  ,TOWN NVARCHAR(30)
  ,COUNTY NVARCHAR(25)
  ,RULE_NO INT
  ,ADDR_EXCP XML
)
AS
BEGIN
  ;WITH
  ADDR_LINES_REF AS (
    SELECT @AL1 AS ADDR_LINES
      UNION ALL
    SELECT @AL2
      UNION ALL
    SELECT @AL3
      UNION ALL
    SELECT @AL4
      UNION ALL
    SELECT @AL5
      UNION ALL
    SELECT @AL6
      UNION ALL
    SELECT @AL7
  ),
  SUFFLE_ADDR_HELPER AS (
    SELECT ADDR_LINES_REF.ADDR_LINES AS ADDR
          ,ROW_NUMBER() OVER (
             ORDER BY
               CASE
                 WHEN ADDR_LINES_REF.ADDR_LINES IS NOT NULL THEN 1
                 ELSE 2
               END) AS RN
      FROM ADDR_LINES_REF
     WHERE ADDR_LINES_REF.ADDR_LINES IN (ADDR_LINES_REF.ADDR_LINES)
  ),
  SHUFFLED_ADDR AS (
    SELECT MAX (CASE WHEN RN=1 THEN ADDR END) AS AL1
          ,MAX (CASE WHEN RN=2 THEN ADDR END) AS AL2
          ,MAX (CASE WHEN RN=3 THEN ADDR END) AS AL3
          ,MAX (CASE WHEN RN=4 THEN ADDR END) AS AL4
          ,MAX (CASE WHEN RN=5 THEN ADDR END) AS AL5
          ,MAX (CASE WHEN RN=6 THEN ADDR END) AS AL6
          ,MAX (CASE WHEN RN=7 THEN ADDR END) AS AL7
          ,SUM (CASE WHEN ADDR IS NULL THEN 0 ELSE 1 END) AS ADDR_COUNT
     FROM SUFFLE_ADDR_HELPER
  ),
  RULES AS (
    SELECT '(?i)(^[0-9]{1,4}[A-Z]{0,1}[ ]{0,1}(&|\/|-)[ ]{0,1}[0-9]{1,4}[A-Z]{0,1}( |,)|^[0-9]{1,4}[A-Z]{0,1}( |,))' AS REGEX
  ),
  PATTERN_MATCH AS (
    SELECT SHUFFLED_ADDR.*
          ,RULES.REGEX AS REGEX
          ,CASE
             WHEN dbo.FN_REGEXMATCHEXTRACT(REGEX,SHUFFLED_ADDR.AL1) <> '' THEN 1
             WHEN dbo.FN_REGEXMATCHEXTRACT(REGEX,SHUFFLED_ADDR.AL2) <> '' AND LEN(dbo.FN_REGEXMATCHEXTRACT(REGEX,SHUFFLED_ADDR.AL2)) <= 6 THEN 2
             ELSE 0
           END AS RULE_NO
     FROM SHUFFLED_ADDR
    CROSS JOIN RULES
  ),
  EXTRACT_PREMISE_NO AS (
    SELECT REGEX
          ,CASE
             WHEN RULE_NO = 1 THEN
               CASE
                 WHEN LEN(dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL1)) > 6 THEN ''
                 ELSE dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL1)
               END  
             WHEN RULE_NO = 2 THEN dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL2)
             WHEN RULE_NO = 0 THEN ''
           END AS PREMISE_NO
     FROM PATTERN_MATCH    
  ),
  EXTRACT_PREMISE_NAME AS (
    SELECT REGEX
          ,CASE
             WHEN RULE_NO = 1 THEN
               CASE
                 WHEN LEN(dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL1)) > 6
                   THEN dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL1)
                 ELSE ''
               END
             WHEN RULE_NO = 0 OR RULE_NO =2 THEN AL1
           END AS PREMISE_NAME
     FROM PATTERN_MATCH
  ),
  EXTRACT_STREET AS (
    SELECT CASE
             WHEN RULE_NO = 1 THEN SUBSTRING(AL1, LEN(dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL1))+2, LEN(AL1) - LEN(dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL1)))
             WHEN RULE_NO = 2 THEN SUBSTRING(AL2, LEN(dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL2))+2, LEN(AL2) - LEN(dbo.FN_REGEXMATCHEXTRACT(REGEX,PATTERN_MATCH.AL2)))
             WHEN RULE_NO = 0 THEN AL2
           END AS STREET
      FROM PATTERN_MATCH
  ),
  EXTRACT_DISTRICT AS (
    SELECT PATTERN_MATCH.*
          ,CASE
             WHEN ADDR_COUNT = 2 THEN
               CASE
                 WHEN  RULE_NO = 1 OR RULE_NO = 2 OR RULE_NO = 0 THEN ''
               END
             WHEN ADDR_COUNT = 3 THEN
               CASE
                 WHEN  RULE_NO = 1 OR RULE_NO = 2 OR RULE_NO = 0 THEN ''
               END
             WHEN ADDR_COUNT = 4 THEN
               CASE
                 WHEN RULE_NO = 1 THEN AL2
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN ''
               END
             WHEN ADDR_COUNT = 5 THEN
               CASE
                 WHEN RULE_NO = 1 THEN AL2+', '+AL3
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN AL3
               END
             WHEN ADDR_COUNT = 6 THEN
               CASE
                 WHEN RULE_NO = 1 THEN  AL2+', '+AL3
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN AL3+', '+AL4
               END
             WHEN ADDR_COUNT = 7 THEN
               CASE
                 WHEN RULE_NO = 1 THEN  AL2+', '+AL3
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN AL3+', '+AL4
               END
           END AS DISTRICT                
    FROM PATTERN_MATCH
  ),
  EXTRACT_TOWN AS (
   SELECT EXTRACT_DISTRICT.*
          ,CASE
             WHEN ADDR_COUNT = 2 THEN
               CASE
                 WHEN RULE_NO = 1 THEN AL2
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN ''
               END
             WHEN ADDR_COUNT = 3 THEN
               CASE
                 WHEN RULE_NO = 1 THEN AL2
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN AL3
               END
             WHEN ADDR_COUNT = 4 THEN
               CASE
                 WHEN RULE_NO = 1 OR RULE_NO = 2 OR RULE_NO = 0 THEN AL3
               END
             WHEN ADDR_COUNT = 5 THEN
               CASE
                 WHEN RULE_NO = 1 OR RULE_NO = 2 OR RULE_NO = 0 THEN AL4
               END
             WHEN ADDR_COUNT = 6 THEN
               CASE
                 WHEN RULE_NO = 1 THEN  AL4+', '+AL5
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN AL5
               END
             WHEN ADDR_COUNT = 7 THEN
               CASE
                 WHEN RULE_NO = 1 THEN  AL4+', '+AL5
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN AL5+', '+AL6
              END
           END AS TOWN
    FROM EXTRACT_DISTRICT
  ),
  EXTRACT_COUNTY AS (
    SELECT EXTRACT_TOWN.*
          ,CASE
             WHEN ADDR_COUNT = 2 THEN
               CASE
                 WHEN RULE_NO = 1 OR  RULE_NO = 2 OR RULE_NO = 0 THEN ''
               END
             WHEN ADDR_COUNT = 3 THEN
               CASE
                 WHEN RULE_NO = 1 THEN AL3
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN ''
               END
             WHEN ADDR_COUNT = 4 THEN
               CASE
                 WHEN RULE_NO = 1 OR RULE_NO = 2 OR RULE_NO = 0 THEN AL4
               END
             WHEN ADDR_COUNT = 5 THEN
               CASE
                 WHEN RULE_NO = 1 OR RULE_NO = 2 OR RULE_NO = 0 THEN AL5
               END
             WHEN ADDR_COUNT = 6 THEN
               CASE
                 WHEN RULE_NO = 1 OR RULE_NO = 2 OR RULE_NO = 0 THEN  AL6
               END
             WHEN ADDR_COUNT = 7 THEN
               CASE
                 WHEN RULE_NO = 1 THEN  AL6+', '+AL7
                 WHEN RULE_NO = 2 OR RULE_NO = 0 THEN AL7
               END
           END AS COUNTY
    FROM EXTRACT_TOWN
  ),
  EXTRACT_ALL AS (
    SELECT PREMISE_NAME
          ,PREMISE_NO
          ,STREET
          ,DISTRICT
          ,TOWN
          ,COUNTY
          ,RULE_NO
      FROM EXTRACT_COUNTY
     CROSS JOIN EXTRACT_PREMISE_NO
     CROSS JOIN EXTRACT_STREET
     CROSS JOIN EXTRACT_PREMISE_NAME
  ),
  REMOVE_SPACES AS (
    SELECT CASE WHEN PREMISE_NAME = '' THEN NULL ELSE PREMISE_NAME END AS PREMISE_NAME
          ,CASE WHEN PREMISE_NO = '' THEN NULL ELSE PREMISE_NO END AS PREMISE_NO
          ,CASE WHEN STREET = '' THEN NULL ELSE STREET END AS STREET
          ,CASE WHEN DISTRICT = '' THEN NULL ELSE DISTRICT END AS DISTRICT
          ,CASE WHEN TOWN = '' THEN NULL ELSE TOWN END AS TOWN
          ,CASE WHEN COUNTY = '' THEN NULL ELSE COUNTY END AS COUNTY
          ,RULE_NO
      FROM EXTRACT_ALL
  ),
  LOG_EXCEPTIONS AS (
    SELECT REMOVE_SPACES.*
          ,CASE
             WHEN LEN(PREMISE_NAME) > 40 
               THEN (SELECT EXCEP FROM  dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'PREMISE_NAME',PREMISE_NAME))
             ELSE NULL
           END AS EXCP_PRMISE_NAME
          ,CASE
             WHEN LEN(STREET) > 40
               THEN (SELECT EXCEP FROM dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'STREET',STREET))
             ELSE NULL
           END AS EXCP_STREET
          ,CASE
             WHEN LEN(DISTRICT) > 40 
               THEN (SELECT EXCEP FROM dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'DISTRICT',DISTRICT))
             ELSE NULL
           END AS EXCP_DISTRICT
          ,CASE
             WHEN LEN(TOWN) > 30
               THEN (SELECT EXCEP FROM dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'TOWN',TOWN))
             ELSE NULL
           END AS EXCP_TOWN
          ,CASE
             WHEN LEN(COUNTY) > 25
               THEN (SELECT EXCEP FROM dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'COUNTY',COUNTY))
             ELSE NULL
         END AS EXCP_COUNTY
      FROM REMOVE_SPACES 
  ),
  CHECK_OVERFLOW AS (
    SELECT CASE
             WHEN LEN(PREMISE_NAME) > 40 
               THEN SUBSTRING(PREMISE_NAME,1,40) 
             ELSE PREMISE_NAME 
           END AS PREMISE_NAME
          ,PREMISE_NO
          ,CASE
             WHEN LEN(STREET) > 40 
               THEN SUBSTRING(STREET,1,40) 
             ELSE STREET 
           END AS STREET
          ,CASE
             WHEN LEN(DISTRICT) > 40 
               THEN SUBSTRING(DISTRICT,1,40) 
             ELSE DISTRICT 
           END AS DISTRICT
          ,CASE 
             WHEN LEN(TOWN) > 30 
               THEN SUBSTRING(TOWN,1,30) 
             ELSE TOWN
           END AS TOWN
          ,CASE
             WHEN LEN(COUNTY) > 25 
               THEN SUBSTRING(COUNTY,1,25) 
             ELSE COUNTY 
           END AS COUNTY
          ,RULE_NO
         ,CAST( CONCAT (  CAST ( EXCP_PRMISE_NAME AS NVARCHAR(MAX) )
                         ,CAST ( EXCP_STREET      AS NVARCHAR(MAX) )
                         ,CAST ( EXCP_DISTRICT    AS NVARCHAR(MAX) )
                         ,CAST ( EXCP_TOWN        AS NVARCHAR(MAX) )
                         ,CAST ( EXCP_COUNTY      AS NVARCHAR(MAX) )
                       )  AS XML
              ) AS EXCP
      FROM LOG_EXCEPTIONS  
  )
  INSERT INTO @PARSED_OUT_ADDR
  SELECT PREMISE_NAME
        ,PREMISE_NO
        ,STREET
        ,DISTRICT
        ,TOWN
        ,COUNTY
        ,RULE_NO
        ,EXCP
    FROM CHECK_OVERFLOW
    OPTION (MAXRECURSION 0)
  RETURN
END

GO




IF OBJECT_ID(N'dbo.FN_DEEDSTITLE_SPLIT',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_DEEDSTITLE_SPLIT')) IS NOT NULL
DROP FUNCTION dbo.FN_DEEDSTITLE_SPLIT
GO


CREATE FUNCTION dbo.FN_DEEDSTITLE_SPLIT
(
   @PROPLRTITLENO VARCHAR(MAX)
  ,@X02_KEY VARCHAR(16) = NULL
  ,@REC_CODE CHAR(7) = NULL
)
RETURNS
@PARSED_OUT_TITLE TABLE
(
   TITLE1 NVARCHAR(12)
  ,TITLE2 NVARCHAR(12)
  ,TITLE3 NVARCHAR(12)
  ,TITLE4 NVARCHAR(12)
  ,DEEDS_EXCP XML
)
BEGIN
  DECLARE @START INT, @END INT, @I INT
     SELECT @START = 1
           ,@END = CHARINDEX('/', @PROPLRTITLENO)
           ,@I = 1 
    WHILE @START < LEN(@PROPLRTITLENO) + 1
    BEGIN
        IF @END = 0  
            SET @END = LEN(@PROPLRTITLENO) + 1
        IF @I = 1
           IF LEN(SUBSTRING(@PROPLRTITLENO, @START, @END - @START)) > 12
             BEGIN
                INSERT INTO @PARSED_OUT_TITLE (TITLE1) VALUES(SUBSTRING(@PROPLRTITLENO, @START,12))
                UPDATE @PARSED_OUT_TITLE
                   SET DEEDS_EXCP = (SELECT EXCEP FROM dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'TITLE1',SUBSTRING ( @PROPLRTITLENO, @START, @END - @START )))
             END
            ELSE
             INSERT INTO @PARSED_OUT_TITLE (TITLE1) VALUES(SUBSTRING(@PROPLRTITLENO, @START, @END - @START))
        IF @I = 2
           IF LEN(SUBSTRING(@PROPLRTITLENO, @START, @END - @START)) >12
             BEGIN
                  UPDATE @PARSED_OUT_TITLE 
                     SET TITLE2 = (SUBSTRING ( @PROPLRTITLENO, @START, 12 ))
                  UPDATE @PARSED_OUT_TITLE
                     SET DEEDS_EXCP = (SELECT EXCEP FROM dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'TITLE2',SUBSTRING ( @PROPLRTITLENO, @START, @END - @START )))
             END
           ELSE
             UPDATE @PARSED_OUT_TITLE
                SET TITLE2 = (SUBSTRING(@PROPLRTITLENO, @START,  @END - @START))
        IF @I = 3
          IF LEN(SUBSTRING(@PROPLRTITLENO, @START, @END - @START)) >12
            BEGIN
              UPDATE @PARSED_OUT_TITLE
                 SET TITLE3 = (SUBSTRING(@PROPLRTITLENO, @START, 12))
              UPDATE @PARSED_OUT_TITLE
                 SET DEEDS_EXCP = (SELECT EXCEP FROM dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'TITLE3',SUBSTRING ( @PROPLRTITLENO, @START, @END - @START )))
            END
           ELSE
             UPDATE @PARSED_OUT_TITLE
                SET TITLE3 = (SUBSTRING(@PROPLRTITLENO, @START,  @END - @START))
        IF @I = 4
           IF LEN(SUBSTRING(@PROPLRTITLENO, @START, @END - @START)) >12
             BEGIN
               UPDATE @PARSED_OUT_TITLE
                  SET TITLE1 = (SUBSTRING(@PROPLRTITLENO, @START, 12))
                  UPDATE @PARSED_OUT_TITLE
                     SET DEEDS_EXCP = (SELECT EXCEP FROM dbo.FN_EXCEPTION1(@REC_CODE,'W:LENGTH-OVERRUN',@X02_KEY,'TITLE4',SUBSTRING ( @PROPLRTITLENO, @START, @END - @START )))
             END
           ELSE
           UPDATE @PARSED_OUT_TITLE 
              SET TITLE3 = (SUBSTRING(@PROPLRTITLENO, @START,  @END - @START))
        SET @START = @END + 1
        SET @END = CHARINDEX('/', @PROPLRTITLENO, @START)
        SET @I = @I + 1
    END
    RETURN
END




GO



--------------------------------------------Generating XML format Exception END-----------------------------------------------------------------

--------------------------------------------Generating DATE functions START-----------------------------------------------------------------
/* CREATION THE LAST DAY OF PREVIOUS YEAR FUNCTION FOR BASE QUERY*/

IF OBJECT_ID(N'dbo.FN_GETNUMERICVALUE',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_GETNUMERICVALUE')) IS NOT NULL
DROP FUNCTION dbo.FN_GETNUMERICVALUE
GO

CREATE FUNCTION dbo.FN_GETNUMERICVALUE
(
  @num VARCHAR(1000)
)
RETURNS VARCHAR(1000)
AS
BEGIN
WHILE PATINDEX('%[^0-9]%', @num) > 0
SET @num = STUFF(@num, PATINDEX('%[^0-9]%', @num), 1, '')
RETURN @num
END 
GO


IF OBJECT_ID(N'dbo.FN_DATE_PREV_MONTH',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_DATE_PREV_MONTH')) IS NOT NULL
DROP FUNCTION dbo.FN_DATE_PREV_MONTH
GO

CREATE FUNCTION dbo.FN_DATE_PREV_MONTH
(
@date DATE
)
RETURNS DATE
AS BEGIN
  RETURN DATEADD(MONTH,-1,@date)
END
GO

IF OBJECT_ID(N'dbo.FN_DATE_NEXT_MONTH',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_DATE_NEXT_MONTH')) IS NOT NULL
DROP FUNCTION dbo.FN_DATE_NEXT_MONTH
GO

CREATE FUNCTION dbo.FN_DATE_NEXT_MONTH
(
@date DATE
)
RETURNS DATE
AS BEGIN
  RETURN DATEADD(MONTH,1,@date)
END
GO

IF OBJECT_ID(N'dbo.FN_LASTDAY_OF_PREVYEAR',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_LASTDAY_OF_PREVYEAR')) IS NOT NULL
DROP FUNCTION dbo.FN_LASTDAY_OF_PREVYEAR
GO

CREATE FUNCTION dbo.FN_LASTDAY_OF_PREVYEAR
(
@date DATE
)
RETURNS DATE
AS BEGIN
   RETURN DATEADD(dd,-1,DATEADD(YY,DATEDIFF(YY,0,@date),0))
END
GO

/* CREATION THE FIRST DAY OF PREVIOUS YEAR FUNCTION FOR BASE QUERY*/

IF OBJECT_ID(N'dbo.FN_FIRSTDAY_OF_PREVYEAR',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_FIRSTDAY_OF_PREVYEAR')) IS NOT NULL
DROP FUNCTION dbo.FN_FIRSTDAY_OF_PREVYEAR
GO

CREATE FUNCTION dbo.FN_FIRSTDAY_OF_PREVYEAR
(
@date DATE
)
RETURNS DATE
AS BEGIN
   RETURN DATEADD(yy, DATEDIFF(yy, 0,@date) - 1, 0)
END
GO


IF OBJECT_ID(N'dbo.FN_END_OF_MONTH',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_END_OF_MONTH')) IS NOT NULL
DROP FUNCTION dbo.FN_END_OF_MONTH
GO

CREATE FUNCTION dbo.FN_END_OF_MONTH
(
@date DATE
)
RETURNS DATE
AS BEGIN
  RETURN EOMONTH ( @date )
END
GO

IF OBJECT_ID(N'dbo.FN_FIRST_OF_MONTH',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_FIRST_OF_MONTH')) IS NOT NULL
DROP FUNCTION dbo.FN_FIRST_OF_MONTH
GO

CREATE FUNCTION dbo.FN_FIRST_OF_MONTH
(
@date DATE
)
RETURNS DATE
AS BEGIN
  RETURN DATEADD(DAY,1,EOMONTH ( @date, -1 ) )
END
GO



/* CREATION OF THE END OF THE PREVIOUS MONTH FUNCTION FOR BASE QUERY*/

IF OBJECT_ID(N'dbo.FN_END_OF_PREV_MONTH',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_END_OF_PREV_MONTH')) IS NOT NULL
DROP FUNCTION dbo.FN_END_OF_PREV_MONTH
GO

CREATE FUNCTION dbo.FN_END_OF_PREV_MONTH
(
@date DATE
)
RETURNS DATE
AS BEGIN
  RETURN EOMONTH ( @date, -1 )
END
GO

/* CREATION OF THE FIRST OF NEXT MONTH FUNCTION FOR BASE QUERY*/

IF OBJECT_ID(N'dbo.FN_FIRST_OF_NEXT_MONTH',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_FIRST_OF_NEXT_MONTH')) IS NOT NULL
DROP FUNCTION dbo.FN_FIRST_OF_NEXT_MONTH
GO

CREATE FUNCTION dbo.FN_FIRST_OF_NEXT_MONTH
(
  @DATE DATE
)
RETURNS DATE
AS
BEGIN
DECLARE @OUTPUT DATE
SET @OUTPUT = DATEADD(DAY,1, EOMONTH(@DATE))
RETURN @OUTPUT
END
GO

/* CREATION OF THE END OF THE BEFORE MONTH FUNCTION FOR BASE QUERY*/

IF OBJECT_ID(N'dbo.FN_ENDOFMONTHBEFORE',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_ENDOFMONTHBEFORE')) IS NOT NULL
DROP FUNCTION dbo.FN_ENDOFMONTHBEFORE
GO

CREATE FUNCTION dbo.FN_ENDOFMONTHBEFORE
(
  @DATE DATE
)
RETURNS INT
AS
BEGIN
DECLARE @OUTPUT INT
SET @OUTPUT = MONTH(EOMONTH ( @DATE, -1 ))
RETURN @OUTPUT
END
GO

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'FN_CONVERT_DATE') AND TYPE IN (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION dbo.FN_CONVERT_DATE
GO
CREATE FUNCTION dbo.FN_CONVERT_DATE
(
	-- ADD THE PARAMETERS FOR THE FUNCTION HERE
	@DATE_IN VARCHAR(8) 
)
RETURNS VARCHAR(8)
AS
BEGIN
		
	DECLARE @DATE_OUT VARCHAR(8)= NULL;
	DECLARE @STARTDATEINT INT = -99999;
	DECLARE @STARTDATE DATE = CONVERT (DATE ,'01-01-1753');

	DECLARE @GIVENDATEINT INT = CAST(@DATE_IN AS INT);           

	
	IF ((@GIVENDATEINT != -99999) AND (@GIVENDATEINT != 99999) AND  (@GIVENDATEINT != 0))
		BEGIN
			-- IF GIVEN DATE INT IS NOT -99999 ,99999 , 0 THEN ADD NUMBER DAYS 
			SET @DATE_OUT = CONVERT(VARCHAR, (DATEADD(DD ,(@GIVENDATEINT - @STARTDATEINT) , @STARTDATE)),112) ;
			
		END;
	
	
	RETURN @DATE_OUT

END
GO

--Function to determine the last day of the current year. It is used in the view : VW_FILTER_ACPEDYMD_YEARENDBEFOREMIGR
IF OBJECT_ID(N'dbo.FN_LASTDAY_OF_CURYEAR',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_LASTDAY_OF_CURYEAR')) IS NOT NULL
DROP FUNCTION dbo.FN_LASTDAY_OF_CURYEAR
GO


CREATE FUNCTION dbo.FN_LASTDAY_OF_CURYEAR
(
@DATE DATE
)
RETURNS DATE
AS BEGIN
   RETURN DATEADD(yy, DATEDIFF(yy,0,GETDATE()) + 1, -1)
END
GO
--------------------------------------------Generating DATE functions END-----------------------------------------------------------------

--------------------------------------------Generating SPLIT function START-----------------------------------------------------------------

IF  EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID(N'dbo.FN_SPLIT') AND TYPE IN (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION dbo.FN_SPLIT
GO
CREATE FUNCTION dbo.FN_SPLIT
(
	@DATA NVARCHAR(MAX)
)
RETURNS @RETTABLE TABLE 
(
	VALUE VARCHAR(2000)
)
AS 
BEGIN

DECLARE @INDIVIDUAL VARCHAR(20) = NULL

IF @DATA IS NULL
INSERT INTO @RETTABLE VALUES('')

IF LTRIM(@DATA) = ''
INSERT INTO @RETTABLE VALUES('')

WHILE LEN(@DATA) > 0
BEGIN
    IF PATINDEX('%|%',@DATA) > 0
    BEGIN
        SET @INDIVIDUAL = SUBSTRING(@DATA, 0, PATINDEX('%|%',@DATA))
        INSERT INTO @RETTABLE VALUES( @INDIVIDUAL)
        SET @DATA = SUBSTRING(@DATA, LEN(@INDIVIDUAL + '|') + 1, LEN(@DATA))
    END
    ELSE
    BEGIN
        SET @INDIVIDUAL = @DATA
        SET @DATA = NULL
        INSERT INTO @RETTABLE VALUES( @INDIVIDUAL)
    END
END
RETURN
END

GO

--------------------------------------------Generating SPLIT function END-----------------------------------------------------------------

--------------------------------------------Generating ADDRESS SPLIT function START-----------------------------------------------------------------

--Asihwaray is working on this and will provide updated version
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'dbo.FN_ADDR_COMPARE') AND type in (N'FN'))
DROP FUNCTION dbo.FN_ADDR_COMPARE
GO 
CREATE FUNCTION dbo.FN_ADDR_COMPARE
(
   @BUILD_NAME NVARCHAR(MAX)
  ,@BUILD_NO NVARCHAR(MAX)
  ,@POSTCODE NVARCHAR(MAX)
)
RETURNS NVARCHAR(MAX)
AS
BEGIN
  DECLARE @ADDRESS NVARCHAR(MAX)
         ,@BLDNG_NAME NVARCHAR(40)
         ,@BLDNG_NO NVARCHAR(6)
         ,@POST_CODE NVARCHAR(10)

  SET @BLDNG_NAME = dbo.FN_REGEXMATCHREPLACE('\W|_',@BUILD_NAME)
  SET @BLDNG_NO = dbo.FN_REGEXMATCHREPLACE('\W|_',@BUILD_NO)
  SET @POST_CODE = dbo.FN_REGEXMATCHREPLACE('\W|_',@POSTCODE)

  SET @ADDRESS = UPPER(CONCAT(COALESCE(@BLDNG_NAME,''),COALESCE(@BLDNG_NO,''),COALESCE(@POST_CODE,'')))
  RETURN @ADDRESS
END
GO



--------------------------------------------Generating ADDRESS SPLIT function END-----------------------------------------------------------------

IF OBJECT_ID('FN_LUTSRC_STANDARDISE',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME ='FN_LUTSRC_STANDARDISE')) IS NOT NULL
DROP FUNCTION dbo.FN_LUTSRC_STANDARDISE
GO

CREATE FUNCTION dbo.FN_LUTSRC_STANDARDISE
(
    @SRC_VALUE NVARCHAR(MAX)
)
RETURNS VARCHAR(50)
BEGIN

DECLARE @VALUE NVARCHAR (255)

 IF @SRC_VALUE IS NULL
   SET @VALUE = ('<NULL>')

 ELSE IF LTRIM(RTRIM(@SRC_VALUE)) = ''
    SET @VALUE = ('<EMPTY>')

 ELSE
  SET @VALUE = @SRC_VALUE

    RETURN @VALUE
END

GO

/*
 * Author: Akila Kesavan
 * Creation Date: 10/11/2015
 * Description: This function will compare by removing non A-Z and 0-9 (i.e. punctuation & spaces) and change the string into uppercase as per the logic specified for the field : CUS02.C03-SEPCORADR
 * Revision History:
 *-----------------------------------------------------------------------------------------------------------------------------------------------
 * Version      Date            Developer               Description
 *-----------------------------------------------------------------------------------------------------------------------------------------------
    1.0         10/11/2015      Akila Kesavan           Initial Draft(According to Mapping Spec Version 1.3  
 *-----------------------------------------------------------------------------------------------------------------------------------------------
 */

IF OBJECT_ID(N'dbo.FN_FUZZY_COMPARE',(SELECT TYPE FROM SYS.OBJECTS WHERE NAME =N'FN_FUZZY_COMPARE')) IS NOT NULL
DROP FUNCTION dbo.FN_FUZZY_COMPARE
GO

CREATE FUNCTION dbo.FN_FUZZY_COMPARE
(
 @INPUT_STRING VARCHAR(40)
)
RETURNS VARCHAR(40)
AS BEGIN
  RETURN UPPER(dbo.FN_REGEXMATCHREPLACE('\W|_|[ ]',@INPUT_STRING))
END
GO
